-- Notes on QEMU->LLVM Translation
Ryan Whelan
Last updated 4/20/12

    In S2E, the code that handles the translation from the QEMU IR (TCG) to the
LLVM IR is done in qemu/tcg/tcg-llvm.cpp.  The generateCode() function is called
for each QEMU translation block, and the result is translated into an LLVM
function, represented in the LLVM IR.  This function in turn calls
generateOperation() for each TCG instruction in the translation block.

    The generateOperation() function is essentially a switch statement for each
type of TCG instruction, and in most cases, it is a one-to-one mapping.  There
are several exceptions for QEMU instructions: mov/movi, call, and
qemu_ld/qemu_st.
    For QEMU move instructions, there is no corresponding move instruction in
the LLVM IR - there is only load and store.  To deal with this, the authors of
S2E have implemented setValue() and getValue() functions.  These functions
create LLVM loads and stores to and from the locations in memory where QEMU CPU
registers are stored.  For temporaries, they are stored in the m_values array of
temporaries.
    For QEMU call instructions, S2E has implemented a helper wrapper function,
which is one of the reasons why S2E currently only works with x86_64.  This
function is called tcg_llvm_helper_wrapper(), and it is implemented in assembly
code in qemu/tcg/x86_64/tcg-target.c.  The address of the helper function is an
argument to this wrapper, so it calls the helper that is passed to it.
    For QEMU qemu_ld/qemu_st instructions, there is a pre-processed
generateQemuMemOp() function to deal with these.  This function essentially
mimics the backend code that gets generated by tcg_out_qemu_ld() and
tcg_out_qemu_st() in qemu/tcg/x86_64/tcg-target.c.  Part of this code involves
an understanding of the QEMU softmmu, and a good explanation about that is
available here:
http://vm-kernel.org/blog/2009/07/10/qemu-internal-part-2-softmmu/
The softmmu maps between guest virtual addresses and host virtual addresses.  On
a hit, an offset is received that can be added to the guest virtual address to
get the host virtual address.  On a miss, a helper is called.  These helpers are
the qemu_ld/st helpers, i.e., __ldb_mmu() which is a preprocessed function in
softmmu_template.h.  More details are available in the article.  We can map a
host virtual address to a guest physical address using the
qemu_ram_addr_from_host() function.  Inside of gemerateQemuMemOp(), there is an
LLVM branch to see whether it is a hit or a miss in the softmmu; if it is a hit,
then it performs a memory access on the host virtual address directly.  If it is
a miss, it calls the helper function to perform the access and add an entry to
the softmmu.

    Note: In the current configuration, LLVM optimizations are not being
performed.  Additionally, by looking at the generated LLVM, it seems that there
is an excessive amount of loads and stores of values in the QEMU CPU state.
This should be optimized to only obtain these values once, not every time they
need to be accessed.  For example, if EAX needs to be modified, the IR should
not include code to first obtain the pointer to EAX every single time.

